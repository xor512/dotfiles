#!/bin/bash

if [ "$#" -ne 3 ]; then
    echo "Usage: "$(basename $0)" time1 +|- time2"
    echo
    echo "Shows how many time will it be if we will add say 8 hours"
    echo "to 23.49 or substract 36 minutes from 00.14"
    echo
    echo "time1 and time2 should be in floating point format (with a dot"
    echo "like for example 3.40 which means 3 o'clock in the morning and 40 minutes)"
    echo "3.4 which means 3 o'clock and 4 minutes accordinely".
    echo
    echo "For simplicity (this script is suppossed just to count when to"
    echo "take next dosage of drugs) there is almost no validation, so for example"
    echo "if you will try to subscribe 10 years from 1 year AD you will get"
    echo "gibberish (I am m not going into AD/BC in this simple and stupid script"
    echo
    echo "PS After writing this I've realized that instead of converting hours"
    echo "to minus and back it is enough to add hours and minutes separately"
    echo "and then simply divide sum of minutes by 60, add result to sum of"
    echo "hours and mod of that division leave as minutes, Anyway both solution"
    echo "are simple enough"
    echo
    echo "PPS Please note that you need to add spaces between operators and operator"
    exit 1
fi

time1=$1
operator=$2
time2=$3

# bash makes life of script writer hard.
# it doesn't have any symbol to distinguish between octal
# or decimal numbers. So while all the civilized world
# uses 0o7 for octals - bash uses 07. The problem is that
# in octal system say 09 does not exist and bash interprets
# it as junk. So if one tries to add 09 hours to 02 hours
# treating them like decimal numbers - bash thinks they are
# octal and emits an error saying that 09 is an invalid octal"
# number. So to perform arithmetics # on such numbers
# leading 0s should be removed
ltrim_zeros()
{
    number=$1
    number=`echo $number | sed "s/^0*//"`

    if [[ "${#number}" -eq 0 ]]; then
        number=0
    fi

    # it is a number but it can be greater than 255 (as we convert so not using return
    echo $number 
}

# See comments where this function is used
ladd_zero()
{
    number=$1

    if [[ "${#number}" -lt 2 ]]; then
        number="0${number}"
    fi

    echo $number
}

# See comments where this function is used
radd_zero()
{
    number=$1

    if [[ "${#number}" -lt 2 ]]; then
        if [[ ${number} -eq 0 ]]; then
            number="${number}0"
        else
            number="0${number}"
        fi
    fi

    echo $number
}

time_to_minutes()
{
    time_param=$1

    if [[ "${#time_param}" -eq 1 ]]; then
         # case when there is no dot in number of hours, like in say 2 (which means 2 o'oclock)
         hours=$time_param 
         minutes=0
    else
         hours=`echo $time_param | cut -d '.' -f1`
         minutes=`echo $time_param | cut -d '.' -f2`
    fi

    # If someone omits minutes like $(basename $0) 6 + 4, set minutes to 0
    # to not have junk there (affecting the result)
    if [[ -z "$minutes" ]] ; then
        minutes=0
    fi

    hours=`ltrim_zeros $hours`
    minutes=`ltrim_zeros $minutes`
    minutes_in_hours=$((${hours} * 60))
    time_in_minutes=$((${minutes_in_hours} + ${minutes}))

    # return result (it's a string so not using returning status 0-255)
    echo $time_in_minutes
}

minutes_to_time()
{
     result_minutes=$1

     result_hours=$(($result_minutes / 60 % 24))
     rest_minutes=$(($result_minutes % 60))

    if [[ "${result_hours}" -eq 24 ]]; then
        result_hours=0
    fi

    if [[ "${rest_minutes}" -eq 60 ]]; then
        result_hours=$((++${result_hours}))
        rest_minutes=0
    fi

    # Make 04.xx from 4.xx and such (leading zeros where
    # removed by ltrim_zeros to make arithmetic work) 
    result_hours=`ladd_zero $result_hours`

    # Make 04.xx from 04.x (this could happen e.g. when)
    # we add 01.20 to 01.40, there is no rest then, but
    # we have to leave only one zero to make arithmetics
    # work. There is another case when result it 07.1 but
    # should be written as 07.01
    rest_minutes=`radd_zero $rest_minutes`

    # return result (it's a string so not using returning status 0-255)
    echo "${result_hours}.${rest_minutes}"
}

time_in_minutes1=`time_to_minutes $time1`
time_in_minutes2=`time_to_minutes $time2`

minutes_sum=$(($time_in_minutes1 + $time_in_minutes2))
minutes_diff=$(($time_in_minutes1 - $time_in_minutes2))
result_sum=`minutes_to_time $minutes_sum`
result_diff=`minutes_to_time $minutes_diff`

case "$operator" in
    +)
        echo "Addition:"
        echo "$time1 + $time2 = $result_sum"
        ;;
    -)
        echo "Substraction:"
        echo "$time1 - $time2 = $result_diff"
        ;;
    *)
        echo "ERROR: Unknown operator, use '+' or '-'"
        ;;
esac

